---
title: "Concurrency in F# – Part III – Erlang Style Message Passing"
date: 2007-10-24T22:55:14.6670000
draft: false
---

<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Why is the introduction of Erlang style message passing into F# interesting? Well you may have never heard of Erlang but if you’ve ever used a cell phone you’ve probably used an Erlang system. Erlang was originally built by Ericsson and released as open source in 1998, it was built to support the highly distributed and fault-tolerant systems required to support mobile phone networks. Many people consider Erlang to be the language that gets concurrency right.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">So if you want to do concurrency why not just use Erlang? Well the fact that Erlang is built on its own custom runtime means there are few libraries or tools available for it, well few compared to the number available for .NET. <a href="http://www.tbray.org/ongoing/When/200x/2007/09/21/Erlang">Tim Brady has series of post on Erlang</a> were he criticizes it for slow file I/O and regular expressions; again I would put these problems down to the custom run time. So taking what’s good from Erlang and put it into a language, that’s build on a platform that has lots of libraries and tools and good file I/O and fast regular expressions, would seem like a very good idea.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Erlang programs are typically composed of agents that pass messages to each other, the messages being passed between agents via a message queue. In F# we create an agent using the MailboxProcessor.Start function, this function takes a function as a parameter and is passed an instance of the message and must return an asynchronous workflow. In this work flow you will typically read messages from the mailbox and process them. Below we see an example of a word counting agent, that is an agent that will count the number of times it is passed a word. It is the sort of thing we might use to perform statistical analysis on a text:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: green; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">/// The internal type of messages for the agent<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">type</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> Message = Word <span style="COLOR: blue">of</span> string | Fetch <span style="COLOR: blue">of</span> IChannel&lt;Map&lt;string,int&gt;&gt; | Stop<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">type</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> WordCountingAgent() = <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> counter = MailboxProcessor.Start(<span style="COLOR: blue">fun</span> inbox <span style="COLOR: blue">-&gt;<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">             </span><span style="COLOR: green">// The states of the message processing state machine...<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">             </span><span style="COLOR: blue">let</span> <span style="COLOR: blue">rec</span> loop(words : Map&lt;string,int&gt;) = <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                </span>async { <span style="COLOR: blue">let!</span> msg = inbox.Receive()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                        </span><span style="COLOR: blue">match</span> msg <span style="COLOR: blue">with</span> <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                        </span>| Word word <span style="COLOR: blue">-&gt;<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                            </span><span style="COLOR: blue">if</span> words.ContainsKey word <span style="COLOR: blue">then<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                                </span><span style="COLOR: blue">let</span> count = words.[word]<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                                </span><span style="COLOR: blue">let</span> words = words.Remove word<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                                </span><span style="COLOR: blue">return!</span> loop(words.Add (word, (count + 1)) )<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                            </span><span style="COLOR: blue">else<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                                </span><span style="COLOR: green">// do printfn "New word: %s" word<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                                </span><span style="COLOR: blue">return!</span> loop(words.Add (word, 1) )<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                                </span><o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                        </span>| Stop <span style="COLOR: blue">-&gt;</span> <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                            </span><span style="COLOR: green">// exit<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                  </span><span style="mso-spacerun: yes">          </span><span style="COLOR: blue">return</span> ()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                        </span>| Fetch<span style="mso-spacerun: yes">  </span>replyChannel<span style="mso-spacerun: yes">  </span><span style="COLOR: blue">-&gt;</span> <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                            </span><span style="COLOR: green">// post response to reply channel and continue<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                            </span><span style="COLOR: blue">do</span> replyChannel.Post(words) <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                            </span><span style="COLOR: blue">return!</span> loop(words) } <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes"> </span><span style="mso-spacerun: yes">            </span><span style="COLOR: green">// The initial state of the message processing state machine...<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">             </span>loop(Map.empty))<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">member</span> a.AddWord(n) = counter.Post(Word(n))<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">member</span> a.Stop() = counter.Post(Stop)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">member</span> a.Fetch() = counter.PostSync(<span style="COLOR: blue">fun</span> replyChannel <span style="COLOR: blue">-&gt;</span> Fetch(replyChannel))<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">There are two things worth noting about the overall design, first we use a sum type to represent all the possible types of messages, this is a very common pattern for this style of programming and secondly we wrap our agent in a class to provide a friendlier interface to the outside world. A happy side effect of this is that other .NET languages would find this class really easy to use too.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font size="3"><font face="Calibri">Now if we look more at the implementation details we see all the work is done in the function we pass to MailboxProcessor.Start. Here we read the messages we are posted and perform the relevant actions. The actual work of counting words is done in the “Word” action, here we use a Map, a function data structure similar to a dictionary but immutable, to store the words along with the count for the number of times it has been found. We use the Post function of the MailboxProcessor to post the Word message to the message queue. In the “Fetch” action we return the current Map containing all the words found to date, notice how this is implemented using the special PostSync function provided by the MailboxProcessor. And the “Stop”action stops the agent </font><span style="FONT-FAMILY: Wingdings; mso-ascii-font-family: Calibri; mso-ascii-theme-font: minor-latin; mso-hansi-font-family: Calibri; mso-hansi-theme-font: minor-latin; mso-char-type: symbol; mso-symbol-font-family: Wingdings"><span style="mso-char-type: symbol; mso-symbol-font-family: Wingdings">J</span></span></font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">The advantage of implementing the word counting agent in this way is the agent is now thread safe and can be shared between threads working on related texts freely. Also as we use an immutable map to store the state we can pass this out to the outside world and carry on processing without having to worry about it becoming inconsistent and corrupted.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">To demonstrate this I wrote some code to read from text files and analyze the numbers of occurrences of each word:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> counter = <span style="COLOR: blue">new</span> WordCountingAgent()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> readLines file = <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">  </span>seq { <span style="COLOR: blue">use</span> r = <span style="COLOR: blue">new</span> StreamReader( File.OpenRead file ) <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">while</span> not r.EndOfStream <span style="COLOR: blue">do</span> <span style="COLOR: blue">yield</span> r.ReadLine() } <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> processFile file =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> lines = readLines file<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">for</span> line <span style="COLOR: blue">in</span> lines <span style="COLOR: blue">do<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> punctuation = [| ' '; '.'; '"'; '''; <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">          </span>','; ';'; ':'; '!'; '?'; '-'; '('; ')'; |]<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> words = line.Split(punctuation)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">for</span> word <span style="COLOR: blue">in</span> words <span style="COLOR: blue">do<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span><span style="COLOR: blue">if</span> word.Length &gt; 0 <span style="COLOR: blue">then<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                </span>counter.AddWord word<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> printWords = <span style="COLOR: blue">false<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> main() =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> autoResetEvent = <span style="COLOR: blue">new</span> AutoResetEvent(<span style="COLOR: blue">false</span>)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> files = Directory.GetFiles(<span style="COLOR: #a31515">@"C:\Users\robert\Documents\Fielding"</span>)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> i = ref 0<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">for</span> file <span style="COLOR: blue">in</span> files <span style="COLOR: blue">do<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">use</span> readfile = <span style="COLOR: blue">new</span> BackgroundWorker()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>readfile.DoWork.Add(<span style="COLOR: blue">fun</span> _ <span style="COLOR: blue">-&gt;<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span>printfn <span style="COLOR: #a31515">"Starting '%s'"</span> (Path.GetFileNameWithoutExtension file)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span>processFile file |&gt; ignore )<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>readfile.RunWorkerCompleted.Add(<span style="COLOR: blue">fun</span> _ <span style="COLOR: blue">-&gt;</span> <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span>printfn <span style="COLOR: #a31515">"Finished '%s'"</span> (Path.GetFileNameWithoutExtension file)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span>incr i<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span><span style="COLOR: blue">if</span> !i = files.Length <span style="COLOR: blue">then<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                </span>autoResetEvent.Set() |&gt; ignore)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>readfile.RunWorkerAsync()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">while</span> not (autoResetEvent.WaitOne(100, <span style="COLOR: blue">false</span>)) <span style="COLOR: blue">do<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> words = counter.Fetch()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>printfn <span style="COLOR: #a31515">"Words: %i"</span> words.Count<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> res = counter.Fetch()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>printfn <span style="COLOR: #a31515">"Finished Words: %i"</span> res.Count<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">if</span> printWords <span style="COLOR: blue">then<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>res.Iterate (<span style="COLOR: blue">fun</span> k v <span style="COLOR: blue">-&gt;</span> printfn <span style="COLOR: #a31515">"%s : %i"</span> k v)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>counter.Stop()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>read_line()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">main()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><o:p><font face="Calibri" size="3"> </font></o:p></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">You’ll see in the implementation we use the background worker thread to process the texts, this because we need notification of when the processing has finished and asynchronous workflows do not yet offer this. We could very well have used stuff from the <a href="http://msdn.microsoft.com/msdnmag/issues/07/10/Futures/default.aspx?loc=en">“Task Parallel Library”</a></font><font face="Calibri" size="3">, but I didn’t simply because I thought it would make it easier for people to test the sample for themselves. More on the Task Parallel Library later.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">I’m not sure this is a very realistic approach to the problem as if we were doing it properly we’d probably analyze each text then merger the results (because know the results for each individual text could also be interesting). Also if we were doing it properly we’d probably pay much more attention to how we split up the words. But at the end of the day it is a good way to provide work to test our agent.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">I choose the analyze the works of <a href="http://www.gutenberg.org/browse/authors/f#a537">Henry Fielding</a>, which I downloaded from </font><a href="http://www.gutenberg.org/"><font face="Calibri" color="#800080" size="3">http://www.gutenberg.org</font></a><font face="Calibri" size="3">, I choose Fielding because <span style="mso-spacerun: yes"> </span>I have a soft spot for <a href="http://www.gutenberg.org/etext/6593">Tom Jones</a>, as also because the number of works available on project Gutenberg from Fielding was small enough so I could download them all yet large enough to provide a decent amount of work.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">We run on my duel core machine we get the following output (varies slightly from run to run):</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Starting 'From This World to the Next'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Starting 'Amelia'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Starting 'History of Tom Jones, a Foundling'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Starting 'Joseph Andrews Volume 1'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Starting 'Joseph Andrews Volume 2'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Starting 'Journal of a Voyage to Lisbon - Volume 1'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Starting 'The History of the Life of the Late Mr Jonathan Wild the Great'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Starting 'The Works of Henry Fielding'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Words: 1236<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Finished 'From This World to the Next'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Finished 'Joseph Andrews Volume 1'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Finished 'Journal of a Voyage to Lisbon - Volume 1'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Finished 'The Works of Henry Fielding'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Finished 'Joseph Andrews Volume 2'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Finished 'The History of the Life of the Late Mr Jonathan Wild the Great'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Finished 'Amelia'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Finished 'History of Tom Jones, a Foundling'<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Words: 16610<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-FAMILY: &quot;Courier New&quot;"><font size="3">Finished Words: 24469<o:p></o:p></font></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><o:p><font face="Calibri" size="3"> </font></o:p></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font size="3"><font face="Calibri">There’s a couple of things worth noting about the output. First for quite a while it makes both processors work at full speed. This would seem to suggest that we’re getting the number of threads right – there are threads to carry on working while the other threads are blocked doing I/O. Here the Task Parallel Library’s TaskManager class might have helped us limited the number of threads in action at one time and reduce context switching overhead. But after the last book is processed and we see: </font><span style="FONT-FAMILY: &quot;Courier New&quot;">Finished 'History of Tom Jones, a Foundling'</span><font face="Calibri"> one process carries on working on its own while the other idles, it takes a while before we see </font><span style="FONT-FAMILY: &quot;Courier New&quot;">Finished Words: 24469</span><font face="Calibri">. This effectively means we’ve overloaded our agent and it has not been able to process all the words that we put into it, but thanks to the message queue it did eventually catch up when more work stopped being added. This is why this style of programming is a good choice when the work loaded is varied, even if an agent can process all it work at peak times it can store work up till the system has some idle time and finish processing then.</font></font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><font size="3"><font face="Calibri">It’s also worth noting we only ever see too intermediate word counts (</font><span style="FONT-FAMILY: &quot;Courier New&quot;">Words: 1236</span><font face="Calibri"> and </font><span style="FONT-FAMILY: &quot;Courier New&quot;">Words: 16610</span><font face="Calibri">). The code that produces these word counts is as follows:</font></font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">while</span> not (autoResetEvent.WaitOne(100, <span style="COLOR: blue">false</span>)) <span style="COLOR: blue">do<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> words = counter.Fetch()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>printfn <span style="COLOR: #a31515">"Words: %i"</span> words.Count<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><o:p><font face="Calibri" size="3"> </font></o:p></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><font face="Calibri" size="3">So given that samples runs for about considerable longer that 200 m/s we might expect to see alot more that 2 intermediate word counts. We don’t because fetching the dictionary has to be done synchronously so our “Fetch” action has to wait in the queue to be process. This means that the thread is blocked at the </font><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">counter.Fetch()</span><font face="Calibri" size="3"> instruction for considerably longer than it is blocked at </font><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">autoResetEvent.WaitOne(100, <span style="COLOR: blue">false</span>)</span><font face="Calibri" size="3">, and thus we only see too intermediate counts.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><o:p><font face="Calibri" size="3"> </font></o:p></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><font face="Calibri" size="3">Wrapping it up, I think we’ve see than Erlang style message passing provides an interesting model for creating concurrent applications. Even if a more realistic application would be composed of many agents working together passing messages to each other we have seen the core of an agents tasks, it ability to keep a consistent data structure while being called from many different threads. Writing this post made me reflect on the difference between this style of programming and the style offered by the TaskManager in the Task Parallel Library. It seems to me that in the Task Parallel Library you only ever control inputting messages/actions to the queue where as using a MailboxProcessor in F# allows you to control both ends of the queue. The TaskManager has the advantage that it can use also sort of clever heuristics to know when to start new threads/actions as it controls the executions of new tasks. However, using a MailboxProcessor in F# would seem to offer some interesting possibilities not yet possibly with the Task Parallel Library.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><font face="Calibri" size="3">Anyway, this series will continue!</font></p>

### Feedback:

*Feedback was imported from my only blog engine, it's no longer possible to post feedback here.*

**re: Concurrency in F# – Part III – Erlang Style Message Passing - [Tony Nassar](http://slideguitarist.blogspot.com/)**

Robert, I realize you have other work to do, but could you take a second to explain <i>return!</i>? This keyword has only just appeared, and I can't find any documentation of it.

**re: Concurrency in F# – Part III – Erlang Style Message Passing - [Ulf Wiger](http://ulf.wiger.net/weblog)**

Short note on the Tim Bray experiments: the slow file I/O was primarily due to the use of a function intended for human interaction - not batch-mode file processing. That doesn't invalidate your comparison, of course. It's good to have a runtime with lots of library support.<br /><br />What you're showing in your post isn't quite Erlang-style concurrency, but rather perhaps Haskell-style concurrency ;-) If I understand your mailboxes, a thread can handle several mailboxes at any given time. Erlang processes have one mailbox, and allows for selective pattern matching on its contents. The big issue is that you need scoped message reception, and multiple mailboxes can give you that. You might want to take a look at http://www.erlang.se/euc/05/1500Wiger.ppt and sketch a solution in F#.<br /><br />The next steps in erlang-style concurrency are distribution transparency, and process linking and supervision. Then you just need to verify that your implementation scales to at least a few tens of thousand concurrent threads, and you're home free. (:

**re: Concurrency in F# – Part III – Erlang Style Message Passing - [Robert Pickering](http://strangelights.com/)**

Thanks for your feedback, lately I have been reading Joe Armstrong’s “Programming Erlang Software for a Concurrent World” and have come to release some of the limitations of F# mailboxes with respect to Erlang. Clearly the ability to distribute processes so easily is a massive advantage and Erlang’s light weight threading is very nice too.<br /><br />I believe it may be possible to simulate some kind of process linking/supervision tree like behaviour with current messages box implementation, and I’ll definitely take a look at your suggestions of how to use F# mailboxes in a more Erlang like way. However transparent distribution is pretty much out of the question for the moment.<br /><br />In short I’m not trying to pretend that F# concurrency story is anywhere near as good as Erlang’s, but I feel its asynchronous workflows are a small step in the right direction.<br />

**F# Asynchronous Workflows with the Coordination and Concurrency Runtime - [The monad nomad](http://www.monadnomad.com/blog/post/F-Asynchronous-Workflows-with-the-Coordination-and-Concurrency-Runtime.aspx)**

F# Asynchronous Workflows with the Coordination and Concurrency Runtime

