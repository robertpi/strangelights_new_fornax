---
title: "Immutability and Concurrency – Part II – A Review of F#’s Immutable Data Structures"
date: 2008-06-17T08:07:13.9830000
draft: false
---

<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">The first half of this series the accent is on immutable programming, because in the first part of the series we had an introduction to immutable data, and in this second part we’re going to look in depth at immutable programming possibilities, with the idea of show that this is actually not too different to what your used. Once we’ve conquered the immutability we’ll start to dig into the concurrency. The main idea behind this post is take a look at everything that makes working with immutable data bearable, even likable.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><o:p><font face="Calibri" size="3"> </font></o:p></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><strong style="mso-bidi-font-weight: normal"><font size="3"><font face="Calibri">Expressions and Returning Multiple Values (a.k.a. Tuples)<o:p></o:p></font></font></strong></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">In F# everything is an expression. You can have statements too, but these are just expressions that return a special unit type that contains one value, the somewhat cryptic () value. This is largely because values are immutable by default: a statement is a side effect, an admission that a mutation has take place, an expression is something that returns a value, which is how we make progress in the functional world. This has a few interesting effects on our language, and ultimately our way of thing about programming. Consider the following C# fragment:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">string</span> FoundItem(<span style="COLOR: blue">bool</span> found) {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">string</span> foundString;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">if</span> (found) {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>foundString = <span style="COLOR: #a31515">"Found"</span>;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>}<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">else</span> {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>foundString = <span style="COLOR: #a31515">"Not found"</span>;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>}<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">return</span> foundString; <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>}</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Here we have a method that takes an input and through a series of steps: initialise a local, perform an if statement, return the local variable, our method transforms the input into a result. Now let’s take a look at the equivalent in F#:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> foundItem found = <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">if</span> found <span style="COLOR: blue">then<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: #a31515">"Found"<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">else<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: #a31515">"Not found"</span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">In F# our “if” is not a statement, but an expression. So we’re able to throw away the tedious implementation detail of declaring a local and concentrate on the important bit: the transformation. So I think we ultimately we come to think of series of transformations of on the data that we’re using rather than a series of steps that the computer must perform.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">A quick aside: you can of course rewrite the C# in a more expression oriented manor:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">string</span> FoundItemAlt1(<span style="COLOR: blue">bool</span> found) {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">if</span> (found) {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">return</span> <span style="COLOR: #a31515">"Found"</span>;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>}<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">else</span> {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">return</span> <span style="COLOR: #a31515">"Not found"</span>;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>}<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>}<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">string</span> FoundItemAlt2(<span style="COLOR: blue">bool</span> found) {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">return</span> found ? <span style="COLOR: #a31515">"Found"</span> : <span style="COLOR: #a31515">"Not found"</span>;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>}</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">But neither feels particularly like idiomatic C# and lot of C# style guides council against this sort of style, probably because C# doesn’t allow you to return multiple arguments, which makes this style of programming slightly awkward, we’ll look at this issue next.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">So if you don’t know F# you may be thinking that having everything as an expression would make translating the following code fragment difficult, since here we update two local variables: </font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">void</span> FoundItemMessage(<span style="COLOR: blue">bool</span> found) {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">string</span> foundTitle;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">string</span> foundMessagge;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">if</span> (found) {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>foundTitle = <span style="COLOR: #a31515">"Found"</span>;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>foundMessagge = <span style="COLOR: #a31515">"The item was found"</span>;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>}<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">else</span> {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>foundTitle = <span style="COLOR: #a31515">"Not found"</span>;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>foundMessagge = <span style="COLOR: #a31515">"The item wasn't found"</span>;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>}<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: #2b91af">MessageBox</span>.Show(foundMessagge, foundTitle);<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>}</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">In fact it’s very easy to translate this sort of thing because in F# you can return two values or more values from any expression:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> foundItemMessage found = <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> foundTitle, foundMessagge =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">if</span> found <span style="COLOR: blue">then<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span><span style="COLOR: #a31515">"Found"</span>, <span style="COLOR: #a31515">"The item was found"<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">else<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span><span style="COLOR: #a31515">"Not found"</span>, <span style="COLOR: #a31515">"The item wasn't found"<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>MessageBox.Show(foundMessagge, foundTitle)</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Returning multiple items is called returning a tuple, in the above code we return a pair, a special name for a tuple of 2 items, from our if expression and straight away unpack our tuple into the identifiers foundTitle and foundMessage. As you become more familiar with tuples you start to see that in C# we often use mutation to get around the fact we can’t easily return multiple values. In C# it’s a fairly common pattern to update class members as way of returning results when we need to computer two different but related values in method:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">int</span> cost;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">int</span> profit;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">private</span> <span style="COLOR: blue">void</span> ComputeCostProfit(<span style="COLOR: blue">int</span> price) {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: green">// obviously the calculation needs to more complex to<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: green">// justify being a separate method<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>cost = rnd.Next(price);<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>profit = price - cost;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>}<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">void</span> OutputProfit() {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">int</span> price = 42;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>ComputeCostProfit(42);<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: #2b91af">Console</span>.WriteLine(<span style="COLOR: #a31515">"Price: {0} Cost: {1} Profit: {2}"</span>, price, cost, profit);<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>}</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">We can translate this into the following F#:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> computeCostProfit price =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">let</span> cost = rnd.Next(price)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>cost, price - cost<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> outputProfit() =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> price = 42<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> cost, profit = computeCostProfit price<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>Printf.printf <span style="COLOR: #a31515">"Price: %i Cost: %i Profit: %i"</span> price cost profit</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">The F# implementation of computeCostProfit is not only more encapsulated because we no longer rely on updating member field, it’s also thread safe as now all state is held on the threads stack.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">I think now we’re beginning to get a feel for how expressions and tuples can help us avoid the need for mutable state, now let’s take a tour of other immutable types in F#.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><strong style="mso-bidi-font-weight: normal"><font size="3"><font face="Calibri">Records<o:p></o:p></font></font></strong></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">In F# records are a way of grouping multiple values and naming the fields. In F# a record looks something like:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">type</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> Person = <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>{ FirstName: string; <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>LastName: string; }</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">And we can construct instances of them like:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> helen = { FirstName = <span style="COLOR: #a31515">"Helen"</span>; LastName = <span style="COLOR: #a31515">"Rippon"</span> }</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">By default all fields in a record are immutable. <span style="mso-spacerun: yes"> </span>This may sound like a horrible grind, as sooner or later we’re bound to want to make a change to the record, but this is why F# provides a nice short-hand syntax for creating new records with one or more fields changed:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> marriedHelen = { helen <span style="COLOR: blue">with</span> LastName = <span style="COLOR: #a31515">"Jones"</span> }</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">It’s also common practices to provide member methods that create copies of record as a convenient way of altering the record:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">type</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> Person = <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>{ FirstName: string; <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>LastName: string; }<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">with</span> <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">member</span> x.Marries lastName = <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span>{ x <span style="COLOR: blue">with</span> LastName = lastName }</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Although here we do more work up front it generally means we have nice short hand way of using our record though out the code:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> marriedHelen = helen.Marries <span style="COLOR: #a31515">"Jones"</span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">At this point you’re probably starting to see that using immutable constructs is as different as you previously may have thought, but maybe starting to worry about the performance of all that copying. This is a real concern, but probably isn’t as bad as you think. Allocation is very quick in a garbage collected environment like the CLR, and the amount of data we’re copying is generally small, in the previous example we’re only coping two pointers since the strings themselves are immutable so need to copy them. In fact, if all your records are immutable then there is only ever need to make a shallow copy, because the data structures your referencing are guaranteed not to change so there’s no need to copy them. Finally garbage collection of new objects is very efficient in the CLR, because its collections are split into generations.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><strong style="mso-bidi-font-weight: normal"><font size="3"><font face="Calibri">List/Set/Map<o:p></o:p></font></font></strong></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">List, Set and Map are F#’s immutable collections. List is a singularly linked list and Set and Map are both based on binary trees with Set being a mathematical “Set” and “Map” being a collection of name value pairs. Again using these types isn’t that different from using mutable types, you just need to keep in mind a new value is being produced every time you add a new value, but this doesn’t change the look and the feel of the code too much. To illustrate this let’s look at initializing a ResizeArray (F#’s name for System.Collections.Generic.List) and initializing a set:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> ra = <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> temp = <span style="COLOR: blue">new</span> ResizeArray&lt;string&gt;()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>temp.Add(<span style="COLOR: #a31515">"toto"</span>)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>temp.Add(<span style="COLOR: #a31515">"lolo"</span>)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>temp.Add(<span style="COLOR: #a31515">"bobo"</span>)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>temp<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> set = <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> temp = Set.empty<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> temp = temp.Add(<span style="COLOR: #a31515">"toto"</span>)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> temp = temp.Add(<span style="COLOR: #a31515">"lolo"</span>)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> temp = temp.Add(<span style="COLOR: #a31515">"bobo"</span>)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>temp</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">I think you’ll agree in both cases the code looks quite similar: it has the same look and feel, but there are a couple of key differences that are important to notice. First notice that we initialise “set” to be “empty”, this is the cute part of programming using immutable data structures there is no need of several different instances of the empty set, it is immutable, so the empty set will always be the empty set and can be shared between all the different sets that the program uses. The second thing to notice is how we need to recapture the reference to the newly created object every time we add a new item:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> temp = temp.Add(<span style="COLOR: #a31515">"toto"</span>)</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">but you’ll be getting used the by now. F#’s list structure works in pretty much the same way expect we use the [] symbol to represent the empty list and the :: symbol to represent adding an item to a list:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> list =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> temp = []<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> temp = <span style="COLOR: #a31515">"toto"</span> :: temp<span style="mso-spacerun: yes">        </span><o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> temp = <span style="COLOR: #a31515">"lolo"</span> :: temp<span style="mso-spacerun: yes">        </span><o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">let</span> temp = <span style="COLOR: #a31515">"bobo"</span> :: temp<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>temp</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Since initialising a list like this can be pretty tedious F# also provides a short had for doing it:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> listShortHand = [ <span style="COLOR: #a31515">"toto"</span>; <span style="COLOR: #a31515">"lolo"</span>; <span style="COLOR: #a31515">"bobo"</span> ]</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><strong style="mso-bidi-font-weight: normal"><font size="3"><font face="Calibri">Looping Using Recursion<o:p></o:p></font></font></strong></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Traditional looping constructs like “for” and “while” are statements and rely on mutation to store temporary results, so you may think translating a section of C# that’s based on while loop, like the section below which calculates whether a complex number is a member of the Mandelbrot set, would be difficult:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: #2b91af">Complex</span> cMax = <span style="COLOR: #2b91af">Complex</span>.Create(1.0, 1.0);<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: #2b91af">Complex</span> cMin = <span style="COLOR: #2b91af">Complex</span>.Create(-1.0, -1.0);<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">int</span> iterations = 18;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">public</span> <span style="COLOR: blue">bool</span> isInMandelbrotSet(<span style="COLOR: #2b91af">Complex</span> c0) {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">bool</span> res = <span style="COLOR: blue">false</span>;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: #2b91af">Complex</span> c = c0;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">int</span> count = 0;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">while</span> ((cMin &lt; c) &amp;&amp; (c &lt; cMax) &amp;&amp; (count &lt; iterations)) {<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>c = (c * c) + c0;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes"> </span><span style="mso-spacerun: yes">       </span>count++;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>}<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span><span style="COLOR: blue">return</span> count == iterations;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>}</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">However loops can be translated into recursive functions, which do not reply on mutation. An example of how the while loop could be translated into a recursive function is shown below. Here the loop is translated into a recursive “check” function which checks the exit condition and if it’s not met recursively calls the check function:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> cMax = complex 1.0 1.0<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> cMin = complex -1.0 -1.0<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> iterations = 18<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> isInMandelbrotSet c0 =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> <span style="COLOR: blue">rec</span> check n c =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>(n = iterations)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>|| (cMin &lt; c) &amp;&amp; (c &lt; cMax) &amp;&amp; check (n + 1) ((c * c) + c0)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>check 0 c0</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">These techniques are very powerful when working with immutable collections. For example it’s common to use recursion and pattern matching work with lists, the below example shows how to transform a list of strings into a list of integers:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> <span style="COLOR: blue">rec</span> mapStringToInt l =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">match</span> l <span style="COLOR: blue">with<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>| hd :: tl <span style="COLOR: blue">-&gt;</span> System.Int32.Parse(hd) :: mapStringToInt tl<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>| [] <span style="COLOR: blue">-&gt;</span> []<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> ints = mapStringToInt [<span style="COLOR: #a31515">"1"</span>; <span style="COLOR: #a31515">"2"</span>; <span style="COLOR: #a31515">"3"</span>]</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Transformations of this nature are so common that very often you don’t need worry about building a recursive function to perform the transformation as a library function “map” is already provide:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> <span style="COLOR: blue">rec</span> map f l =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">   </span><span style="mso-spacerun: yes"> </span><span style="COLOR: blue">match</span> l <span style="COLOR: blue">with<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>| hd :: tl <span style="COLOR: blue">-&gt;</span> f hd :: map f tl<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>| [] <span style="COLOR: blue">-&gt;</span> []</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">You simply need to provide the transformation that you want to apply to each item in the list:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> ints = List.map System.Int32.Parse [<span style="COLOR: #a31515">"1"</span>; <span style="COLOR: #a31515">"2"</span>; <span style="COLOR: #a31515">"3"</span>]</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Another common pattern when working with immutable structures is to use folding to create a summary of the collection. Folding works well with immutable collection because a fold function threads an accumulator value though the computation, that is to say that each function call is passed an accumulator value that was the result of the last function. This is extremely useful when working with immutable data structures as the accumulator provides way to pass state between each iteration without have to resort to mutable data. The below code shows how to use folding to create an F# “Set” from an F# list:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> set = [1;1;2;2;3;3;3] <sup><o:p></o:p></sup></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">          </span>|&gt; List.fold_left (<span style="COLOR: blue">fun</span> acc x <span style="COLOR: blue">-&gt;</span> Set.add x acc ) Set.empty</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Here the “Set.add” function produces a new set that is passed to the next function call via the “acc” accumulator parameter.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">This is such a common thing to do that there is no need to write a function to create a set of a list it is provided for you as a library function:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> altSet = Set.of_list [1;1;2;2;3;3;3]</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><strong style="mso-bidi-font-weight: normal"><font size="3"><font face="Calibri">Constructors/Union Types<o:p></o:p></font></font></strong></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">The union types are a bit unusual because where as records and collections can make sense as either mutable or immutable types, union types <em style="mso-bidi-font-style: normal">generally</em> only make sense as immutable type. A very quick recap for those unfamiliar with union types: a union type is composed of one or more constructors. A “constructor” in the ML (meta language – the family of language that F# comes from) sense is a named type that can contain a fixed number of augments. For instance might declare a constructor of type “vector”:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">type</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> vector = Vector2D <span style="COLOR: blue">of</span> int*int</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">We can compose a constructor, that is, create a new instance:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> myVector = Vector2D (1, 2)</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Then one way to recover the values it contains is to use a function to decompose it:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> x,y = (<span style="COLOR: blue">function</span> Vector2D(x,y) <span style="COLOR: blue">-&gt;</span> x, y) myVector</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Here we use an anonymous function to decompose the values, but we’re just using that to keep the example brief, in reality we’d probably use a named function for better reuse. Also constructors can be decomposed though pattern matching, we’ll cover this we look at union types that compose two or more constructors.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">So constructors can be composed or decomposed, they don’t really have any concept of mutation, that’s why we said earlier they don’t really make sense as mutable data structures, though they can of course contain mutable data:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">type</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> thing = MyThing <span style="COLOR: blue">of</span> Dictionary&lt;string, int&gt;</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">But that’s generally the exception rather than the rule.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">So let’s look at a more realistic example. Union types are often used to represent trees; because individual constructors can contain reference to the type of the original union it’s easy to build recursive data structures that can be used to represent trees. Below is an example of a classic binary tree, the tree is composed of two constructors one a node that contains two “BinaryTree” (a right and left branch) and a “Leaf” that contains the value.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">type</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> BinaryTree&lt;'a&gt; =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>| Node <span style="COLOR: blue">of</span> BinaryTree&lt;'a&gt; * BinaryTree&lt;'a&gt;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>| Leaf <span style="COLOR: blue">of</span> 'a</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">The following shows you how to construct an instance of a very small tree, that contains one node and two leaves:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; COLOR: blue; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> tree = Node(Leaf 1, Leaf 2)</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">To help make sense of how we’d use this data structure, the following code snippet shows us pattern matching over a tree structure to collect the information at the leaves of the tree: </font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> flattenTree tree =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> <span style="COLOR: blue">rec</span> flattenTree tree acc =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">match</span> tree <span style="COLOR: blue">with<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>| Node (right, left) <span style="COLOR: blue">-&gt;</span> <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span>flattenTree right acc<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span>|&gt; flattenTree left<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>| Leaf value <span style="COLOR: blue">-&gt;</span> value :: acc<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>flattenTree tree []</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">The important part is the “match ... with” expression in the middle of the function. Here we break up the union type to see whether it contains a node or a leaf. If we find a leaf we add the value to the accumulator, if we find a node we recursively treat each branch. So here we deconstruct the tree structure while construing a new list.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><strong style="mso-bidi-font-weight: normal"><font size="3"><font face="Calibri">The Accumulator and Environment Patterns<o:p></o:p></font></font></strong></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Even with the help of tuples to allow us to return multiple results we can run into problems with having to pass too much data around, especially if our algorithm becomes very complicated. To cope with this we can use the accumulator and environment patterns. These can be seen in the <a href="http://www.strangelights.com/blog/archive/2008/05/04/1613.aspx">post I made a while ago about an ant colony simulation</a>.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Both patterns concern different ways we can pass data though an algorithm and are really just a name for identifiers than are thread though out the function. In an environment pattern we want pass data down though the algorithm, in an accumulator pattern we want to retrieve data from a function. Both are generally represented as represent as record types, but could equally be tuples too. It’s not uncommon to see functions with both and environment and an accumulator.</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">Let’s dig into an example to see if I can make that a bit clearer. Suppose we want to collect information from the nodes of a tree – a common enough task in functional programming. Now suppose we have the following tree definition:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">type</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> MadTree =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>| Foo <span style="COLOR: blue">of</span> (DateTime * int)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>| Bar <span style="COLOR: blue">of</span> (DateTime * string)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>| Node <span style="COLOR: blue">of</span> ((DateTime * DateTime) * (MadTree * MadTree))</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">We decided that for the moment we are only interested in collecting nodes that are within the time slice specified by the parent node. Therefore we need a way of propagating the time information forward as well as passing the found instances of Foo and Bar back, for this we use an accumulator and an environment:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">type</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> Accumulator =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>{ foundFoos: List&lt;int&gt;;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>foundBars: List&lt;string&gt;; }<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><o:p> </o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">type</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> Environment =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>{ startDate: DateTime;<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">      </span>endDate: DateTime; }</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">So now we can easily write a recursive function using these types to instance of Foo and Bar that we want:</font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> collectFooBars tree =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">   </span><span style="mso-spacerun: yes"> </span><span style="COLOR: blue">let</span> <span style="COLOR: blue">rec</span> collectFooBars tree env acc =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span><span style="COLOR: blue">match</span> tree <span style="COLOR: blue">with<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>| Foo (date, i) <span style="COLOR: blue">-&gt;</span> <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span><span style="COLOR: blue">if</span> env.startDate &lt; date &amp;&amp; date &lt; env.endDate <span style="COLOR: blue">then</span> <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                </span>{ acc <span style="COLOR: blue">with</span> foundFoos = i :: acc.foundFoos }<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span><span style="COLOR: blue">else</span> acc<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>| Bar (date, s) <span style="COLOR: blue">-&gt;</span> <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span><span style="COLOR: blue">if</span> env.startDate &lt; date &amp;&amp; date &lt; env.endDate <span style="COLOR: blue">then</span> <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">                </span>{ acc <span style="COLOR: blue">with</span> foundBars = s :: acc.foundBars }<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span><span style="COLOR: blue">else</span> acc<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>| Node ((startDate, endDate), (ln, rn)) <span style="COLOR: blue">-&gt;<o:p></o:p></span></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span><span style="COLOR: blue">let</span> newEnv = { startDate =<span style="mso-spacerun: yes">  </span>startDate; endDate = endDate }<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span><span style="COLOR: blue">let</span> acc = collectFooBars ln newEnv acc <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">            </span>collectFooBars rn newEnv acc <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>collectFooBars tree <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>{ startDate = DateTime.MaxValue; endDate = DateTime.MaxValue } <o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">        </span>{ foundFoos = []; foundBars = []; }</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><strong style="mso-bidi-font-weight: normal"><font size="3"><font face="Calibri">Concurrency and the Haskell Problem<o:p></o:p></font></font></strong></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">So now finally we get to a little concurrency. The good news if we implement algorithms using these data structures we can on as many threads as we like and we know I’ll never see any threading issues. For example if we have a large list of MadTree that we want to process there’s no problem to spin up a new thread to process each one, provide: </font></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; COLOR: blue; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">let</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"> threadProcessTree tree =<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><span style="COLOR: blue">let</span> thread = <span style="COLOR: blue">new</span> Thread(<span style="COLOR: blue">fun</span> () <span style="COLOR: blue">-&gt;</span> collectFooBars tree |&gt; ignore)<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span>thread.Start()<o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; LINE-HEIGHT: normal; mso-layout-grid-align: none"><span style="FONT-SIZE: 10pt; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes"><span style="mso-spacerun: yes">    </span><o:p></o:p></span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><span style="FONT-SIZE: 10pt; LINE-HEIGHT: 115%; FONT-FAMILY: &quot;Courier New&quot;; mso-no-proof: yes">madTrees |&gt; List.iter threadProcessTree</span></p>
<p class="MsoNormal" style="MARGIN: 0cm 0cm 10pt"><font face="Calibri" size="3">However there is also some bad news ... it’s up us the, programmer, to guarantee that functions we created are “pure”, that is they have no side effects. However F# does help us a bit here, if we know we need a section of a program to be “pure”, if we stick to F# native structures like records and union types, and its native collections then we know it’s pure. But also, in guarantying purity we run into the Haskell problem (or at least Haskell pre-monad revolution problem, as described by <a href="http://channel9.msdn.com/posts/Charles/Simon-Peyton-Jones-Towards-a-Programming-Language-Nirvana/">Simon Peyton Jones in this video</a>), that is if we have no side effects then we cannot observe the results of a function. We can code complex and exciting algorithms but all we can observer is that they make one or more processors get warm. So in the next episode we’ll look at how we can manage concurrency in F# with immutable data structures.</font></p>

### Feedback:

*Feedback was imported from my only blog engine, it's no longer possible to post feedback here.*

**re: Immutability and Concurrency – Part II – A Review of F#’s Immutable Data Structures - Art**

Hi Rob.<br />Just a note to let you know that I'm very interested in your Blog series.<br />In particular I'm interested in how to break the bottle neck interface between the multi/many-core CPU's and the GPGPU's. There are some intersting slides at the Graphics Hardware 2008 conference: <br />http://www.graphicshardware.org/program.html

